/* DO NOT EDIT! */
/* This file was autogenerated by the utils/mk_interfaces.php script. */

#include "interfaces.h"
#include "zend_exceptions.h"
#include "zend_interfaces.h"

/*
 * Property handlers
 * */
 
static zend_object_handlers object_handlers;

<?php foreach ($classes as $ce): ?><?php if ($ce['use_props']): ?>
static HashTable <?= $ce['id'] ?>_prop_handlers;
<?php endif; ?><?php endforeach; ?>

/*
 * Arguments info
 * */

<?php
foreach ($all_classes as $ce) {
	if (!$ce['own_methods'])
		continue;
	
	echo "/* ".$ce['name']." */\n";
	
	foreach ($ce['own_methods'] as $method) {
		switch ($method['hint']['type']) {
			case "obj_info":
				printf("ZEND_BEGIN_ARG_WITH_RETURN_OBJ_INFO_EX(arginfo_class_%s, %d, %d, %s, %d)\n", 
					$method['prefix']."_".$method['name'], (int) $method['hint']['ref'], $method['required'], 
					addslashes($method['hint']['value']), (int) $method['hint']['null']);
			break;
			
			case "type_info":
				printf("ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_%s, %d, %d, %s, %d)\n", 
					$method['prefix']."_".$method['name'], (int) $method['hint']['ref'], $method['required'], 
					addslashes($method['hint']['value']), (int) $method['hint']['null']);
			break;
			
			default:
				printf("ZEND_BEGIN_ARG_INFO_EX(arginfo_class_%s, 0, %d, %d)\n", 
					$method['prefix']."_".$method['name'], (int) $method['hint']['ref'], $method['required']);
			break;
		}
		
		foreach ($method['arginfo'] as $arginfo) {
			$macro = $arginfo['hint']['variadic'] ? 'ARG_VARIADIC' : 'ARG';
			
			switch ($arginfo['hint']['type']) {
				case "obj_info":
					printf("\tZEND_%s_OBJ_INFO(%d, %s, %s, %d)\n", 
						$macro, (int) $arginfo['hint']['ref'], $arginfo['name'], 
						addslashes($arginfo['hint']['value']), (int) $arginfo['hint']['null']);
				break;
				
				case "type_info":
					printf("\tZEND_%s_TYPE_INFO(%d, %s, %s, %d)\n", 
						$macro, (int) $arginfo['hint']['ref'], $arginfo['name'], 
						addslashes($arginfo['hint']['value']), (int) $arginfo['hint']['null']);
				break;
				
				default:
					printf("\tZEND_%s_INFO(%d, %s)\n", $macro, 0, $arginfo['name']);
				break;
			}
		}
		
		echo "ZEND_END_ARG_INFO();\n\n";
	}
}
?>

/*
 * Methods info
 * */
 
<?php foreach ($classes as $ce): ?>
/* <?= $ce['name'] ?> */
static zend_function_entry <?= $ce['id'] ?>_methods[] = {
<?php foreach ($ce['methods'] as $method): ?>
	PHP_ME(<?= $method['prefix'] ?>, <?= $method['name'] ?>, arginfo_class_<?= $method['prefix'] ?>_<?= $method['name'] ?>, <?= $method['modifiers'] ?>)
<?php endforeach; ?>
	PHP_FE_END
};

<?php endforeach; ?>

/*
 * Functions
 * */
static zend_object *_create_object(zend_class_entry *ce TSRMLS_DC) {
	html5_dom_object_wrap *intern = html5_dom_object_wrap_create(ce, &object_handlers);
	
<?php $i = 0; ?>
<?php foreach ($classes as $ce): ?><?php if ($ce['use_props']): ?>
	/* <?= $ce['name'] ?> */
	<?= $i++ ? 'else if' : 'if' ?> (ce == <?= $ce['id'] ?>_ce) {
		intern->prop_handler = &<?= $ce['id'] ?>_prop_handlers;
	}
<?php endif; ?><?php endforeach; ?>
	/* Without properties */
	else {
		intern->prop_handler = NULL;
	}
	
	DOM_GC_TRACE("[NEW] %s (refs=%d)", ce->name->val, GC_REFCOUNT(&intern->std));
	
	return &intern->std;
}

static void _free_object(zend_object *object TSRMLS_DC) {
	html5_dom_object_wrap *intern = html5_dom_object_unwrap(object);
	
	DOM_GC_TRACE("[DESTROY] %s (refs=%d)", object->ce->name->val, GC_REFCOUNT(&intern->std));
	
	html5_dom_object_wrap_free(intern);
}

void html5_dom_interfaces_init() {
	memcpy(&object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));
	object_handlers.offset					= XtOffsetOf(html5_dom_object_wrap, std);
	object_handlers.free_obj				= _free_object;
	object_handlers.clone_obj				= NULL;
	
	object_handlers.read_property			= html5_dom_read_property;
	object_handlers.write_property			= html5_dom_write_property;
	object_handlers.get_property_ptr_ptr	= html5_dom_get_property_ptr_ptr;
	object_handlers.has_property			= html5_dom_has_property;
	object_handlers.get_debug_info			= html5_dom_get_debug_info;
	
	zend_class_entry ce;
<?php
	foreach ($classes as $ce) {
		echo "\n";
		echo "\t/* ".$ce['name']." */\n";
		
		// Define own prop handlers
		if ($ce['props']) {
			echo "\thtml5_dom_prop_handler_list ".$ce['id']."_handlers[] = {\n";
			foreach ($ce['props'] as $prop)
				printf("\t\t{\"%s\", %s__%s}, \n", $prop['name'], $prop['prefix'], $prop['name']);
			echo "\t\t{\"\", NULL}, \n";
			echo "\t};\n";
			
		}
		
		// Init props storage
		if ($ce['use_props'])
			echo "\thtml5_dom_prop_handler_init(&".$ce['id']."_prop_handlers);\n";
		
		// Inherit prop handlers from parents
		foreach (array_reverse($ce['parents']) as $parent_ce) {
			if ($parent_ce['props'] && !$parent_ce['internal'])
				echo "\thtml5_dom_prop_handler_add(&".$parent_ce['id']."_prop_handlers, ".$parent_ce['id']."_handlers);\n";
		}
		
		if ($ce['props']) {
			// Add own prop handlers
			echo "\thtml5_dom_prop_handler_add(&".$ce['id']."_prop_handlers, ".$ce['id']."_handlers);\n";
		}
		
		// Define class
		echo "\tINIT_CLASS_ENTRY(ce, \"".addslashes($ce['name'])."\", ".$ce['id']."_methods);\n";
		echo "\tce.create_object = _create_object;\n";
		
		if ($ce['parents']) {
			echo "\t".$ce['ref']." = zend_register_internal_class_ex(&ce, ".$ce['parents'][0]['ref'].");\n";
		} else {
			echo "\t".$ce['ref']." = zend_register_internal_class(&ce);\n";
		}
		
		// Define constants
		foreach ($ce['consts'] as $const)
			echo "\tzend_declare_class_constant_long(".$ce['ref'].", ZEND_STRS(\"".addslashes($const['name'])."\") - 1, ".$ce['prefix']."__".$const['name'].");\n";
		
		$interfaces = array_map(function ($v) {
			return $v['ref'];
		}, $ce['interfaces']);
		
		if ($interfaces)
			echo "\tzend_class_implements(".$ce['ref'].", ".count($interfaces).", ".implode(", ", $interfaces).");\n";
	}
?>

}

void html5_dom_interfaces_unload() {
<?php foreach ($classes as $ce): ?><?php if ($ce['use_props']): ?>
	zend_hash_destroy(&<?= $ce['id'] ?>_prop_handlers);
<?php endif; ?><?php endforeach; ?>
}
